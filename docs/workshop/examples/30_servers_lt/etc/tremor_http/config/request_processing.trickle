define script process
script
  use std::array;
  use std::json;
  use std::type;

  use utils;

  let VALID_METHODS = ["GET", "POST"];

  # defaults for the server response
  let $response_status = 200;
  # TODO just rely on content-type header only
  let $response_content_type = "application/json";
  # TODO improve usability for setting headers (just string instead of array?)
  let $response_headers = {
    #"content-type": [ "application/json" ],
    "x-powered-by": [ "Tremor" ],
  };

  # count no of requests so far (using the pipeline state mechanism)
  match type::is_null(state) of
    case true =>
      let state = {"count": 1}
    default =>
      let state.count = state.count + 1
  end;

  # --------------------------------------------------------------------------

  # short-circuit for invalid request methods
  match array::contains(VALID_METHODS, $request_method) of
    case false  =>
      let $response_status = 501,

      # can also name the emit port here "error" and handle
      # it same as runtime errors (which goes to "error" port too)
      # or even emit to the default port ("out"). approach here
      # is useful to track application errors though.
      emit {
        "error": "Method not implemented: {$request_method}",
        "event": event,
      } => "app_error"
    default =>
      null
  end;

  let request_url_parsed = utils::parse_url($request_url);

  # short-circuit if url parsing failed
  match request_url_parsed of
    case null =>
      let $response_status = 500,
      emit {
        "error": "Failed to parse the url: {$request_url}",
        "event": event,
      } => "app_error"
    default =>
      null
  end;

  # --------------------------------------------------------------------------

  # content based on path
  match request_url_parsed.path of
    case "/echo" =>
      emit utils::get_request_data(event, $, request_url_parsed)

    case "/snot" =>
      emit "badger"

    case "/ping" =>
      emit ""

    case "/stats" =>
      emit {"requests_processed": state.count}

    case "/error-test" =>
      emit non_existent_var # will throw a runtime error here

    case "/index"  =>
      let data = utils::get_request_data(event, $, request_url_parsed),
      let name = match data.query_parsed of
        case %{present name} => data.query_parsed.name
        default => "world"
    end,
      # serve html!
      let $response_content_type = "text/html",
      # TODO resolve issues of string duplication with heredoc
      #emit """
      #<h1>Hello, {name}!</h1>
      #<p>Your request:</p>
      #<pre>
      #  {json::encode_pretty(data)}
      #</pre>
      #"""
      emit "<h1>Hello {name}!</h1><p>Your request:</p><pre>{json::encode_pretty(data)}</pre>"

    case "/" =>
      # redirect example
      let $response_status = 301,
      let $response_headers.location = [ "/index" ],
      emit ""

    default =>
      let $response_status = 404,
      emit {
        "error": "Path not found: {request_url_parsed.path}",
        "event": event,
      } => "app_error"
  end;
end;

create script process;

# main request processing
select event from in into process;
select event from process into out;

# our defined app errors (still succesful processing from tremor's perspective)
# useful to track these from different port (app_error) for metrics
select event from process/app_error into out;

# tremor runtime errors from the processing script
# TODO naming here should be standardized to one thing (either err or error)
select event from process/error into err;
